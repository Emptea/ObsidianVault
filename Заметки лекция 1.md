- assign - непрерывное присваивание (прямой прокинутый провод), должны быть одинаковые размерности переменных слева и вправо
- 4-х проводная шина следующим образом
```verilog
logic [3:0] c, d;
```
- присваивание в зависимости от значений на другом проводе
```verilog

```
- двумерный массив проводов
```verilog
logic [8:0] d[0:24]; 
```
- форматы
```verilog
wire [10:0] a = 7; // 32-x битноеобрезанное
wire [10:0] b = 'd7; // 'd - указание десятичности числа; 'b - двоичности, 'h - шестнадцатеричности
wire [10:0] b = 11'd7; // явное указание разрядности
```
- конкантенация ```{a , b}```
- процедурное присваивание: всегда, когда меняется сигнал * (любой входной), то выполняется:
```verilog
always @(*) begin
	q = ~a[7:4];
end
```
- мультиплексор: s = 1  y -> d1, s = 0 y -> d0;
```verilog
Y = s ? d1 : d0;
```
или
```verilog
case(option)
0: e  = a;
1: e  = b;
default: e = d;
endcase
```
- деление и остаток от деления ТОЛЬКО для симуляции, т.е. дает сложную реализацию по площади и очень плохие тайминги
- >> - логический сдвиг, >>> - арифметический сдвиг
```verilog
8'b1010_1110' >> 8'b0000_001 = 8'b0001_0101

```
- &, |, ^, ~ - побитовые операции
- &&, ||, ! - булевые логические операции, результат 1 бит
- если к одному, то побитовые превращаются в операции свертки. ИЛИ как операция свертки проверяет четность!
```verilog
&8'b0110_1011 = 1'b0
|8'b0110_1011 = 1'b0
```
- процедурное присваивание через ```@